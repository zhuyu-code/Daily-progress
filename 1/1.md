# buffer
**理解：**
在前端，我们只需做字符串级别的操作，很少接触字节、进制等底层操作，一方面这足以满足日常需求，另一方面Javascript这种应用层语言并不是干这个的；然而在后端，处理文件、网络协议、图片、视频等时是非常常见的，尤其像文件、网络流等操作处理的都是二进制数据。为了让javascript能够处理二进制数据，node封装了一个Buffer类，主要用于操作字节，处理二进制数据。
# stream
**理解：**
前面讲到，流类比水流形容数据的流动，在文件I/O、网络I／O中数据的传输都可以称之为流，流是能统一描述所有常见输入输出类型的模型，是顺序读写字节序列的抽象表示。数据从A端流向B端与从B端流向A端是不一样的，因此，流是有方向的。A端输入数据到B端，对B就是输入流，得到的对象就是可读流；对A就是输出端、得到的对象是可写流。有的流即可以读又可以写，如TCP连接，Socket连接等，称为读写流(Duplex)。还有一种在读写过程中可以修改和变换数据的读写流称为Transform流。
# file
**理解：**
fs文件模块是高阶模块，继承了EventEmitter、stream、path等底层模块，提供了对文件的操作，包括文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统等操作。与node设计思想和其他模块不同的是，fs模块中的所有操作都提供了异步和同步两个版本。fs模块主要由下面几部分组成:
* 读/写文件都有三种方式，那么区别是什么呢？

1. createReadStream/createWriteStream创建一个将文件内容读取为流数据的ReadStream对象，这个方法主要目的就是把数据读入到流中，得到是可读流，方便以流进行操作

2.readFile/writeFile：Node.js会将文件内容视为一个整体，为其分配缓存区并且一次性将文件内容读/写取到缓存区中，在这个期间，Node.js将不能执行任何其他处理，所以当读写大文件的时候，有可能造成缓存区“爆仓”

3.read/write读/写文件内容是不断地将文件中的一小块内容读/写入缓存区，最后从该缓存区中读取文件内容

同步API也是如此。其中最常用的是readFile，读取大文件则采取用，read则提供更为细节、底层的操作，而且read要配合open。
**理解**
1. 使用file读取的方式我们可以得到filepath这个路径，这个路径是用于缓存文件的地方，大家可以打印一下看看。在该路径中可以找到上传的文件。也就是说file读取方式是先在服务器里写入缓存文件，然后我们再读取缓存文件进行操作。在上面的文件操作中file读取方式的IO操作有写入缓存文件，读取缓存文件，写入文件，总共3次IO操作。而stream流的方式没有缓存文件这个操作，也就是说IO操作只有一次。
2. 使用文件会把一整块数据读取到内存中，再响应下面的内容，使用stream的情况下，会将一部分读取内容下面形成pipe管道，然后进行一个管道传输，消耗内存极少。
***
# 参考文档
1. [egg文件操作](https://segmentfault.com/a/1190000020239877)
2. [nodejs官网](http://nodejs.cn/api/buffer.html)
3. [file和stream的测试](https://juejin.im/post/5940a9c3128fe1006a0ab176)